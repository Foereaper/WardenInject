-- Define payloads
Payloads = {}
Payloads.CMH = "local debug = false local CMH = {} local datacache = {} local delim = {'', '', '', '', ''} local pck = {REQ = '', DAT = ''} local function debugOut(prefix, x, msg) if(debug == true) then print(date('%X', time())..' '..x..' '..prefix..': '..msg) end end local function GenerateReqId() local length = 6 local reqId = '' for i = 1, length do reqId = reqId..string.char(math.random(97, 122)) end return reqId end local function ParseMessage(str) str = str or '' local output = {} local valTemp = {} local typeTemp = {} local valMatch = '[^'..table.concat(delim)..']+' local typeMatch = '['..table.concat(delim)..']+' for value in str:gmatch(valMatch) do table.insert(valTemp, value) end for varType in str:gmatch(typeMatch) do for k, v in pairs(delim) do if(v == varType) then table.insert(typeTemp, k) end end end for k, v in pairs(valTemp) do local varType = typeTemp[k] if(varType == 2) then if(v == string.char(tonumber('1A', 16))) then v = '' end elseif(varType == 3) then v = tonumber(v) elseif(varType == 4) then v = Smallfolk.loads(v, #v) elseif(varType == 5) then if(v == 'true') then v = true else v = false end end table.insert(output, v) end valTemp = nil typeTemp = nil return output end local function ProcessVariables(reqId, ...) local splitLength = 200 local arg = {...} local msg = '' for _, v in pairs(arg) do if(type(v) == 'string') then if(#v == 0) then v = string.char(tonumber('1A', 16)) end msg = msg..delim[2] elseif(type(v) == 'number') then msg = msg..delim[3] elseif(type(v) == 'table') then v = Smallfolk.dumps(v) msg = msg..delim[4] elseif(type(v) == 'boolean') then v = tostring(v) msg = msg..delim[5] end msg = msg..v end if not datacache[reqId] then datacache[reqId] = { count = 0, data = {}} end for i=1, msg:len(), splitLength do datacache[reqId].count = datacache[reqId].count + 1 datacache[reqId]['data'][datacache[reqId].count] = msg:sub(i,i+splitLength - 1) end return datacache[reqId] end function CMH.OnReceive(self, event, header, data, Type, sender) if event == 'CHAT_MSG_ADDON' and sender == UnitName('player') and Type == 'WHISPER' then local pfx, source, pckId = header:match('(.)(%u)(.)') if not pfx or not source or not pckId then return end if(pfx == delim[1] and source == 'S') then if(pckId == pck.REQ) then debugOut('REQ', 'Rx', 'REQ received, data: '..data) CMH.OnREQ(sender, data) elseif(pckId == pck.DAT) then debugOut('DAT', 'Rx', 'DAT received, data: '..data) CMH.OnDAT(sender, data) else debugOut('ERR', 'Rx', 'Invalid packet type, aborting') return end end end end local CMHFrame = CreateFrame('Frame') CMHFrame:RegisterEvent('CHAT_MSG_ADDON') CMHFrame:SetScript('OnEvent', CMH.OnReceive) function CMH.OnREQ(sender, data) debugOut('REQ', 'Rx', 'Processing data..') local functionId, linkCount, reqId, addon = data:match('(%d%d)(%d%d%d)(%w%w%w%w%w%w)(.+)'); if not functionId or not linkCount or not reqId or not addon then debugOut('REQ', 'Rx', 'Malformed data, aborting.') return end functionId, linkCount = tonumber(functionId), tonumber(linkCount); if not CMH[addon] then debugOut('REQ', 'Rx', 'Invalid addon, aborting.') return end if not CMH[addon][functionId] then debugOut('REQ', 'Rx', 'Invalid addon function, aborting.') return end if(datacache[reqId]) then datacache[reqId] = nil debugOut('REQ', 'Rx', 'Cache already exists, aborting.') return end datacache[reqId] = {addon = addon, funcId = functionId, count = linkCount, data = {}} debugOut('REQ', 'Rx', 'Header validated, cache created. Awaitng data..') end function CMH.OnDAT(sender, data) debugOut('DAT', 'Rx', 'Validating data..') local reqId = data:sub(1, 6) local payload = data:sub(#reqId+1) if not reqId then debugOut('DAT', 'Rx', 'Request ID missing, aborting.') return end if not datacache[reqId] then debugOut('DAT', 'Rx', 'Cache does not exist, aborting.') return end local reqTable = datacache[reqId] local sizeOfDataCache = #reqTable.data if reqTable.count == 0 then debugOut('DAT', 'Rx', 'Function expects no data, triggering function..') local func = CMH[reqTable.addon][reqTable.funcId] if func then _G[func](sender, {}) datacache[reqId] = nil debugOut('DAT', 'Rx', 'Function '..func..' @ '..reqTable.addon..' executed, cache cleared.') end return end if sizeOfDataCache+1 > reqTable.count then debugOut('DAT', 'Rx', 'Received more data than expected. Aborting.') return end reqTable['data'][sizeOfDataCache+1] = payload sizeOfDataCache = #reqTable.data debugOut('DAT', 'Rx', 'Data part '..sizeOfDataCache..' of '..reqTable.count..' added to cache.') if(sizeOfDataCache == reqTable.count) then debugOut('DAT', 'Rx', 'All expected data received, processing..') local fullPayload = table.concat(reqTable.data); local VarTable = ParseMessage(fullPayload) local func = CMH[reqTable.addon][reqTable.funcId] if func then _G[func](sender, VarTable) datacache[reqId] = nil debugOut('DAT', 'Rx', 'Function '..func..' @ '..reqTable.addon..' executed, cache cleared.') end end end function CMH.SendREQ(functionId, linkCount, reqId, addon) local header = string.format('%01s%01s%01s', delim[1], 'C', pck.REQ) local data = string.format('%02d%03d%06s%0'..tostring(#addon)..'s', functionId, linkCount, reqId, addon) SendAddonMessage(header, data, 'WHISPER', UnitName('player')) debugOut('REQ', 'Tx', 'Sent REQ with ID '..reqId..', Header '..header..', DAT '..data..' sending DAT..') end function CMH.SendDAT(reqId) local header = string.format('%01s%01s%01s', delim[1], 'C', pck.DAT) if(#datacache[reqId]['data'] == 0) then SendAddonMessage(header, reqId, 'WHISPER', UnitName('player')) else for _, v in pairs (datacache[reqId]['data']) do local payload = reqId..v SendAddonMessage(header, payload, 'WHISPER', UnitName('player')) end end datacache[reqId] = nil debugOut('DAT', 'Tx', 'Sent all DAT for ID '..reqId..', cache cleared, closing.') end function RegisterServerResponses(config) if(CMH[config.Prefix]) then return; end CMH[config.Prefix] = {} for functionId, functionName in pairs(config.Functions) do CMH[config.Prefix][functionId] = functionName end end function SendClientRequest(prefix, functionId, ...) local reqId = GenerateReqId() local varTable = ProcessVariables(reqId, ...) CMH.SendREQ(functionId, varTable.count, reqId, prefix) CMH.SendDAT(reqId) end"
Payloads.StatPointUI = "local config = {Prefix = 'StatPointUI', Functions = {[1] = 'OnCacheReceived'}} StatPointUI = {['cache'] = {}} function StatPointUI.OnLoad() StatPointUI.mainFrame = CreateFrame('Frame', config.Prefix, CharacterFrame) StatPointUI.mainFrame:SetToplevel(true) StatPointUI.mainFrame:SetSize(200, 260) StatPointUI.mainFrame:SetBackdrop( { bgFile = 'Interface/TutorialFrame/TutorialFrameBackground', edgeFile = 'Interface/DialogFrame/UI-DialogBox-Border', edgeSize = 16, tileSize = 32, insets = {left = 5, right = 5, top = 5, bottom = 5} } ) StatPointUI.mainFrame:SetPoint('TOPRIGHT', 170, -20) StatPointUI.mainFrame:Hide() StatPointUI.titleBar = CreateFrame('Frame', config.Prefix..'TitleBar', StatPointUI.mainFrame) StatPointUI.titleBar:SetSize(135, 25) StatPointUI.titleBar:SetBackdrop( { bgFile = 'Interface/CHARACTERFRAME/UI-Party-Background', edgeFile = 'Interface/DialogFrame/UI-DialogBox-Border', tile = true, edgeSize = 16, tileSize = 16, insets = {left = 5, right = 5, top = 5, bottom = 5} } ) StatPointUI.titleBar:SetPoint('TOP', 0, 9) StatPointUI.titleBarText = StatPointUI.titleBar:CreateFontString(config.Prefix..'TitleBarText') StatPointUI.titleBarText:SetFont('Fonts/FRIZQT__.TTF', 13) StatPointUI.titleBarText:SetSize(190, 5) StatPointUI.titleBarText:SetPoint('CENTER', 0, 0) StatPointUI.titleBarText:SetText('|cffFFC125Attribute Points|r') local rowOffset = -30 local titleOffset = -100 local btnOffset = 40 local rowContent = {'Strength', 'Agility', 'Stamina', 'Intellect', 'Spirit'} for k, v in pairs(rowContent) do StatPointUI[v] = {} StatPointUI[v].Val = StatPointUI.mainFrame:CreateFontString(config.Prefix..v..'Val') StatPointUI[v].Val:SetFont('Fonts/FRIZQT__.TTF', 15) if (k == 1) then StatPointUI[v].Val:SetPoint('CENTER', StatPointUI.titleBar, 'CENTER', 30, rowOffset) else local tmp = rowContent[k - 1] StatPointUI[v].Val:SetPoint('CENTER', StatPointUI[tmp].Val, 'CENTER', 0, rowOffset) end StatPointUI[v].Val:SetText('0') StatPointUI[v].Title = StatPointUI.mainFrame:CreateFontString(config.Prefix..v..'Title') StatPointUI[v].Title:SetFont('Fonts/FRIZQT__.TTF', 15) StatPointUI[v].Title:SetPoint('LEFT', StatPointUI[v].Val, 'LEFT', titleOffset, 0) StatPointUI[v].Title:SetText(v..':') StatPointUI[v].Button = CreateFrame('Button', config.Prefix..v..'Button', StatPointUI.mainFrame) StatPointUI[v].Button:SetSize(20, 20) StatPointUI[v].Button:SetPoint('RIGHT', StatPointUI[v].Val, 'RIGHT', btnOffset, 0) StatPointUI[v].Button:EnableMouse(false) StatPointUI[v].Button:Disable() StatPointUI[v].Button:SetNormalTexture('Interface/BUTTONS/UI-SpellbookIcon-NextPage-Up') StatPointUI[v].Button:SetHighlightTexture('Interface/BUTTONS/UI-Panel-MinimizeButton-Highlight') StatPointUI[v].Button:SetPushedTexture('Interface/BUTTONS/UI-SpellbookIcon-NextPage-Down') StatPointUI[v].Button:SetDisabledTexture('Interface/BUTTONS/UI-SpellbookIcon-NextPage-Disabled') StatPointUI[v].Button:SetScript( 'OnMouseUp', function() SendClientRequest(config.Prefix, 2, k) PlaySound('UChatScrollButton') end ) end StatPointUI.pointsLeftVal = StatPointUI.mainFrame:CreateFontString(config.Prefix..'PointsLeftVal') StatPointUI.pointsLeftVal:SetFont('Fonts/FRIZQT__.TTF', 15) local tmp = rowContent[#rowContent] StatPointUI.pointsLeftVal:SetPoint('CENTER', StatPointUI[tmp].Val, 'CENTER', 0, rowOffset) StatPointUI.pointsLeftVal:SetText('0') StatPointUI.pointsLeftTitle = StatPointUI.mainFrame:CreateFontString(config.Prefix..'PointsLeftVal') StatPointUI.pointsLeftTitle:SetFont('Fonts/FRIZQT__.TTF', 15) StatPointUI.pointsLeftTitle:SetPoint('LEFT', StatPointUI.pointsLeftVal, 'LEFT', titleOffset, 0) StatPointUI.pointsLeftTitle:SetText('Points left:') StatPointUI.resetButton = CreateFrame('Button', config.Prefix..'ResetButton', StatPointUI.mainFrame) StatPointUI.resetButton:SetSize(100, 25) StatPointUI.resetButton:SetPoint('CENTER', StatPointUI.titleBar, 'CENTER', 0, -220) StatPointUI.resetButton:EnableMouse(true) StatPointUI.resetButton:SetText('RESET') StatPointUI.resetButton:SetNormalFontObject('GameFontNormalSmall') local ntex = StatPointUI.resetButton:CreateTexture() ntex:SetTexture('Interface/Buttons/UI-Panel-Button-Up') ntex:SetTexCoord(0, 0.625, 0, 0.6875) ntex:SetAllPoints() StatPointUI.resetButton:SetNormalTexture(ntex) local htex = StatPointUI.resetButton:CreateTexture() htex:SetTexture('Interface/Buttons/UI-Panel-Button-Highlight') htex:SetTexCoord(0, 0.625, 0, 0.6875) htex:SetAllPoints() StatPointUI.resetButton:SetHighlightTexture(htex) local ptex = StatPointUI.resetButton:CreateTexture() ptex:SetTexture('Interface/Buttons/UI-Panel-Button-Down') ptex:SetTexCoord(0, 0.625, 0, 0.6875) ptex:SetAllPoints() StatPointUI.resetButton:SetPushedTexture(ptex) StatPointUI.resetButton:SetScript( 'OnMouseUp', function() SendClientRequest(config.Prefix, 3) PlaySound('UChatScrollButton') end ) PaperDollFrame:HookScript( 'OnShow', function() StatPointUI.mainFrame:Show() end ) PaperDollFrame:HookScript( 'OnHide', function() StatPointUI.mainFrame:Hide() end ) StatPointUI.pointsLeftVal:SetText(StatPointUI.cache[6]) PaperDollFrame:HookScript( 'OnShow', function() StatPointUI.mainFrame:Show() end ) PaperDollFrame:HookScript( 'OnHide', function() StatPointUI.mainFrame:Hide() end ) end function OnCacheReceived(sender, argTable) StatPointUI.cache = argTable[1] local rowContent = {'Strength', 'Agility', 'Stamina', 'Intellect', 'Spirit'} for i = 1, 5 do local rci = rowContent[i] StatPointUI[rci].Val:SetText(StatPointUI.cache[i]) if (StatPointUI.cache[i] > 0) then StatPointUI[rci].Val:SetTextColor(0, 1, 0, 1) else StatPointUI[rci].Val:SetTextColor(1, 1, 1, 1) end if (StatPointUI.cache[6] > 0) then StatPointUI[rci].Button:EnableMouse(true) StatPointUI[rci].Button:Enable() else StatPointUI[rci].Button:EnableMouse(false) StatPointUI[rci].Button:Disable() end end StatPointUI.pointsLeftVal:SetText(StatPointUI.cache[6]) end RegisterServerResponses(config) StatPointUI.OnLoad() SendClientRequest(config.Prefix, 1)"
Payloads.Queue = "local Queue = {} function Queue.__index(que, key) return Queue[key] end function NewQueue() local t = {first = 0, last = -1} setmetatable(t, Queue) return t end function Queue.pushleft(que, value) local first = que.first - 1 que.first = first que[first] = value return first end function Queue.pushright(que, value) local last = que.last + 1 que.last = last que[last] = value return last end function Queue.popleft(que) local first = que.first if first > que.last then error('que is empty') end local value = que[first] que[first] = nil que.first = first + 1 return value end function Queue.popright(que) local last = que.last if que.first > last then error('que is empty') end local value = que[last] que[last] = nil que.last = last - 1 return value end function Queue.peekleft(que) return que[que.first] end function Queue.peekright(que) return que[que.last] end function Queue.empty(que) return que.last < que.first end function Queue.size(que) return que.last - que.first + 1 end function Queue.clear(que) local l, r = self:getrange() for i = l, r do que[idx] = nil end que.first, que.last = 0, -1 end function Queue.get(que, idx) if idx < que.first or idx > que.last then return end return que[idx] end function Queue.getrange(que) return que.first, que.last end function Queue.gettable(que) return que end return NewQueue"
Payloads.LibStub = "local LIBSTUB_MAJOR, LIBSTUB_MINOR = 'LibStub', 2 local LibStub = _G[LIBSTUB_MAJOR] if not LibStub or LibStub.minor < LIBSTUB_MINOR then LibStub = LibStub or {libs = {}, minors = {} } _G[LIBSTUB_MAJOR] = LibStub LibStub.minor = LIBSTUB_MINOR function LibStub:NewLibrary(major, minor) assert(type(major) == 'string', 'Bad argument #2 to `NewLibrary` (string expected)') minor = assert(tonumber(strmatch(minor, '%d+')), 'Minor version must either be a number or contain a number.') local oldminor = self.minors[major] if oldminor and oldminor >= minor then return nil end self.minors[major], self.libs[major] = minor, self.libs[major] or {} return self.libs[major], oldminor end function LibStub:GetLibrary(major, silent) if not self.libs[major] and not silent then error(('Cannot find a library instance of %q.'):format(tostring(major)), 2) end return self.libs[major], self.minors[major] end function LibStub:IterateLibraries() return pairs(self.libs) end setmetatable(LibStub, { __call = LibStub.GetLibrary }) end"
Payloads.LibWindow = "local MAJOR = 'LibWindow-1.1' local MINOR = tonumber(('$Revision: 8 $'):match('(%d+)')) local lib = LibStub:NewLibrary(MAJOR,MINOR) if not lib then return end local min,max,abs = min,max,abs local pairs = pairs local tostring = tostring local UIParent,GetScreenWidth,GetScreenHeight,IsAltKeyDown = UIParent,GetScreenWidth,GetScreenHeight,IsAltKeyDown local function print(msg) ChatFrame1:AddMessage(MAJOR..': '..tostring(msg)) end lib.utilFrame = lib.utilFrame or CreateFrame('Frame') lib.delayedSavePosition = lib.delayedSavePosition or {} lib.windowData = lib.windowData or {} lib.embeds = lib.embeds or {} local mixins = {} local function getStorageName(frame, name) local names = lib.windowData[frame].names if names then if names[name] then return names[name] end if names.prefix then return names.prefix .. name; end end return name; end local function setStorage(frame, name, value) lib.windowData[frame].storage[getStorageName(frame, name)] = value end local function getStorage(frame, name) return lib.windowData[frame].storage[getStorageName(frame, name)] end lib.utilFrame:SetScript('OnUpdate', function(this) this:Hide() for frame,_ in pairs(lib.delayedSavePosition) do lib.delayedSavePosition[frame] = nil lib.SavePosition(frame) end end) local function queueSavePosition(frame) lib.delayedSavePosition[frame] = true lib.utilFrame:Show() end mixins['RegisterConfig']=true function lib.RegisterConfig(frame, storage, names) if not lib.windowData[frame] then lib.windowData[frame] = {} end lib.windowData[frame].names = names lib.windowData[frame].storage = storage end local nilParent = { GetWidth = function() return GetScreenWidth() * UIParent:GetScale() end, GetHeight = function() return GetScreenHeight() * UIParent:GetScale() end, GetScale = function() return 1 end, } mixins['SavePosition']=true function lib.SavePosition(frame) local parent = frame:GetParent() or nilParent local s = frame:GetScale() local left,top = frame:GetLeft()*s, frame:GetTop()*s local right,bottom = frame:GetRight()*s, frame:GetBottom()*s local pwidth, pheight = parent:GetWidth(), parent:GetHeight() local x,y,point; if left < (pwidth-right) and left < abs((left+right)/2 - pwidth/2) then x = left; point='LEFT'; elseif (pwidth-right) < abs((left+right)/2 - pwidth/2) then x = right-pwidth; point='RIGHT'; else x = (left+right)/2 - pwidth/2; point=''; end if bottom < (pheight-top) and bottom < abs((bottom+top)/2 - pheight/2) then y = bottom; point='BOTTOM'..point; elseif (pheight-top) < abs((bottom+top)/2 - pheight/2) then y = top-pheight; point='TOP'..point; else y = (bottom+top)/2 - pheight/2; end if point=='' then point = 'CENTER' end setStorage(frame, 'x', x) setStorage(frame, 'y', y) setStorage(frame, 'point', point) setStorage(frame, 'scale', s) frame:ClearAllPoints() frame:SetPoint(point, frame:GetParent(), point, x/s, y/s); end mixins['RestorePosition']=true function lib.RestorePosition(frame) local x = getStorage(frame, 'x') local y = getStorage(frame, 'y') local point = getStorage(frame, 'point') local s = getStorage(frame, 'scale') if s then (frame.lw11origSetScale or frame.SetScale)(frame,s) else s = frame:GetScale() end if not x or not y then x=0; y=0; point='CENTER' end x = x/s y = y/s frame:ClearAllPoints() if not point and y==0 then point='CENTER' end if not point then frame:SetPoint('TOPLEFT', frame:GetParent(), 'BOTTOMLEFT', x, y) queueSavePosition(frame) return end frame:SetPoint(point, frame:GetParent(), point, x, y) end mixins['SetScale']=true function lib.SetScale(frame, scale) setStorage(frame, 'scale', scale); (frame.lw11origSetScale or frame.SetScale)(frame,scale) lib.RestorePosition(frame) end function lib.OnDragStart(frame) lib.windowData[frame].isDragging = true frame:StartMoving() end function lib.OnDragStop(frame) frame:StopMovingOrSizing() lib.SavePosition(frame) lib.windowData[frame].isDragging = false if lib.windowData[frame].altEnable and not IsAltKeyDown() then frame:EnableMouse(false) end end local function onDragStart(...) return lib.OnDragStart(...) end local function onDragStop(...) return lib.OnDragStop(...) end mixins['MakeDraggable']=true function lib.MakeDraggable(frame) assert(lib.windowData[frame]) frame:SetMovable(true) frame:SetScript('OnDragStart', onDragStart) frame:SetScript('OnDragStop', onDragStop) frame:RegisterForDrag('LeftButton') end function lib.OnMouseWheel(frame, dir) local scale = getStorage(frame, 'scale') if dir<0 then scale=max(scale*0.9, 0.1) else scale=min(scale/0.9, 3) end lib.SetScale(frame, scale) end local function onMouseWheel(...) return lib.OnMouseWheel(...) end mixins['EnableMouseWheelScaling']=true function lib.EnableMouseWheelScaling(frame) frame:SetScript('OnMouseWheel', onMouseWheel) end lib.utilFrame:SetScript('OnEvent', function(this, event, key, state) if event=='MODIFIER_STATE_CHANGED' then if key == 'LALT' or key == 'RALT' then for frame,_ in pairs(lib.altEnabledFrames) do if not lib.windowData[frame].isDragging then frame:EnableMouse(state == 1) end end end end end) mixins['EnableMouseOnAlt']=true function lib.EnableMouseOnAlt(frame) assert(lib.windowData[frame]) lib.windowData[frame].altEnable = true frame:EnableMouse(not not IsAltKeyDown()) if not lib.altEnabledFrames then lib.altEnabledFrames = {} lib.utilFrame:RegisterEvent('MODIFIER_STATE_CHANGED') end lib.altEnabledFrames[frame] = true end function lib:Embed(target) if not target or not target[0] or not target.GetObjectType then error('Usage: LibWindow:Embed(frame)', 1) end target.lw11origSetScale = target.SetScale for name, _ in pairs(mixins) do target[name] = self[name] end lib.embeds[target] = true return target end for target, _ in pairs(lib.embeds) do lib:Embed(target) end"
Payloads.AIO = "assert(not AIO, 'AIO is already loaded. Possibly different versions!') local AIO_ENABLE_DEBUG_MSGS = false local AIO_ENABLE_PCALL = true local AIO_ENABLE_TRACEBACK = false local AIO_ENABLE_MSGPRINT = false local AIO_TIMEOUT_INSTRUCTIONCOUNT = 1e8 local AIO_MSG_CACHE_SPACE = 5e5 local AIO_MSG_CACHE_TIME = 15*1000 local AIO_MSG_CACHE_DELAY = 5*1000 local AIO_UI_INIT_DELAY = 5*1000 local AIO_MSG_COMPRESS = true local AIO_CODE_OBFUSCATE = true local AIO_ERROR_LOG = false local assert = assert local type = type local tostring = tostring local pairs = pairs local ipairs = ipairs local ssub = string.sub local match = string.match local ceil = ceil or math.ceil local floor = floor or math.floor local sbyte = strbyte or string.byte local schar = string.char local tconcat = table.concat local select = select local pcall = pcall local xpcall = xpcall local loadstring = loadstring or load local unpack = unpack or table.unpack local AIO_GetTime = os and os.time or function() return GetTime()*1000 end local AIO_GetTimeDiff = os and os.difftime or function(_now, _then) return _now-_then end local AIO_SERVER = false local AIO_VERSION = 1.74 local AIO_ShortMsg = schar(1)..schar(1) local AIO_Compressed = 'C' local AIO_Uncompressed = 'U' local AIO_Prefix = 'AIO' AIO_Prefix = ssub((AIO_Prefix), 1, 16) local AIO_ServerPrefix = ssub(('S'..AIO_Prefix), 1, 16) local AIO_ClientPrefix = ssub(('C'..AIO_Prefix), 1, 16) assert(#AIO_ServerPrefix == #AIO_ClientPrefix) local AIO_MsgLen = 255 -1 -#AIO_ServerPrefix -#AIO_ShortMsg local MSG_MIN = 1 local MSG_MAX = 2^16-767 AIO = { 	unpack = unpack, } local AIO = AIO local AIO_SAVEDFRAMES = {} local AIO_SAVEDVARS = {} local AIO_SAVEDVARSCHAR = {} local AIO_INITED = false local AIO_HANDLERS = {} local AIO_INITHOOKS = {} local AIO_BLOCKHANDLES = {} local AIO_ADDONSORDER = {} local NewQueue = NewQueue or require('queue') local Smallfolk = Smallfolk or require('smallfolk') local lualzw = lualzw or require('lualzw') local LibWindow = LibStub('LibWindow-1.1') function AIO.GetVersion() return AIO_VERSION end local function AIO_16tostring(uint16) assert(uint16 <= 2^16-767, 'Too high value') assert(uint16 >= 0, 'Negative value') local high = floor(uint16 / 254) local l = high +1 local r = uint16 - high * 254 +1 return schar(l)..schar(r) end local function AIO_stringto16(str) local l = sbyte(ssub(str, 1,1)) -1 local r = sbyte(ssub(str, 2,2)) -1 local val = l*254 + r assert(val <= 2^16-767, 'Too high value') assert(val >= 0, 'Negative value') return val end function AIO_RESET() AIO_SAVEDVARS = nil AIO_SAVEDVARSCHAR = nil AIO_sv_Addons = nil AIO_SAVEDFRAMES = {} end function AIO_debug(...) if AIO_ENABLE_DEBUG_MSGS then print('AIO:', ...) end end local function AIO_extractN(...) return select('#', ...), ... end local function AIO_pcall(f, ...) assert(type(f) == 'function') if not AIO_ENABLE_PCALL then return f(...) end local data = {AIO_extractN(pcall(f, ...))} if not data[2] then if AIO_ERROR_LOG then AIO.Handle('AIO', 'Error', data[3]) end if AIO_ENABLE_TRACEBACK then _ERRORMESSAGE(data[3]) else print(data[3]) end return end return unpack(data, 3, data[1]+1) end local function AIO_ReadFile(path) AIO_debug('Reading a file') assert(type(path) == 'string', '#1 string expected') local f = assert(io.open(path, 'rb')) local str = f:read('*all') f:close() return str end local plrdata = {} local removeque = NewQueue() local function RemoveData(guid, msgid) local pdata = plrdata[guid] if pdata then if msgid then local data = pdata[msgid] if data then pdata[msgid] = nil pdata.ramque:gettable()[data.ramquepos] = nil removeque:gettable()[data.remquepos] = nil end else local que = pdata.ramque:gettable() local l, r = pdata.ramque:getrange() for i = l, r do if que[i] then removeque:gettable()[que[i].remquepos] = nil end end plrdata[guid] = nil end end end local function ProcessRemoveQue() if removeque:empty() then return end local now = AIO_GetTime() local l, r = removeque:getrange() for i = l, r do local v = removeque:popleft() if v then if AIO_GetTimeDiff(now, v.stamp) < AIO_MSG_CACHE_TIME then AIO_debug('removing outdated incomplete message') removeque:pushleft(v) break end RemoveData(v.guid, v.id) end end end local frame = CreateFrame('Frame') local timer = AIO_MSG_CACHE_DELAY local function ONUPDATE(self, diff) if timer > diff then timer = timer - diff else ProcessRemoveQue() timer = AIO_MSG_CACHE_DELAY end end frame:SetScript('OnUpdate', ONUPDATE) local function AIO_SendAddonMessage(msg, player) SendAddonMessage(AIO_ClientPrefix, msg, 'WHISPER', UnitName('player')) end local function AIO_Send(msg, player, ...) assert(type(msg) == 'string', '#1 string expected') assert(not AIO_SERVER or type(player) == 'userdata', '#2 player expected') AIO_debug('Sending message length:', #msg) if AIO_ENABLE_MSGPRINT then print('sent:', msg) end if #msg <= AIO_MsgLen then AIO_SendAddonMessage(AIO_ShortMsg..msg, player) else local guid = 1 if not plrdata[guid] then plrdata[guid] = { stored = 0, ramque = NewQueue(), MSG_GUID = MSG_MIN, } end local pdata = plrdata[guid] local msglen = (AIO_MsgLen-4) local parts = ceil(#msg / msglen) local header = AIO_16tostring(pdata.MSG_GUID)..AIO_16tostring(parts) if pdata.MSG_GUID >= MSG_MAX then pdata.MSG_GUID = MSG_MIN else pdata.MSG_GUID = pdata.MSG_GUID+1 end for i = 1, parts do AIO_SendAddonMessage(header..AIO_16tostring(i)..ssub(msg, ((i-1)*msglen)+1, (i*msglen)), player) end end if ... then for i = 1, select('#',...) do AIO_Send(msg, select(i, ...)) end end end local msgmt = {} function msgmt.__index(tbl, key) return msgmt[key] end function msgmt:Add(Name, ...) assert(Name, '#1 Block must have name') self.params[#self.params+1] = {select('#', ...), Name, ...} self.assemble = true return self end function msgmt:Append(msg2) assert(type(msg2) == 'table', '#1 table expected') for i = 1, #msg2.params do assert(type(msg2.params[i]) == 'table', '#1['..i..'] table expected') self.params[#self.params+1] = msg2.params[i] end self.assemble = true return self end function msgmt:Assemble() if not self.assemble then return self end self.MSG = Smallfolk.dumps(self.params) self.assemble = false return self end function msgmt:Send(player, ...) assert(not AIO_SERVER or player, '#1 player is nil') AIO_Send(self:ToString(), player, ...) return self end function msgmt:Clear() for i = 1, #self.params do self.params[i] = nil end self.MSG = nil self.assemble = false return self end function msgmt:ToString() return self:Assemble().MSG end function msgmt:HasMsg() return #self.params > 0 end function AIO.Msg() local msg = {params = {}, MSG = nil, assemble = false} setmetatable(msg, msgmt) return msg end local preinitblocks = {} local function AIO_HandleBlock(player, data, skipstored) local HandleName = data[2] assert(HandleName, 'Invalid handle, no handle name') if not AIO_INITED and (HandleName ~= 'AIO' or data[3] ~= 'Init') then preinitblocks[#preinitblocks+1] = data AIO_debug('Received block before Init:', HandleName, data[1], data[3]) return end local handledata = AIO_BLOCKHANDLES[HandleName] if not handledata then error('Unknown AIO block handle: '..tostring(HandleName)) end handledata(player, unpack(data, 3, data[1]+2)) if not skipstored and AIO_INITED and HandleName == 'AIO' and data[3] == 'Init' then for i = 1, #preinitblocks do AIO_HandleBlock(player, preinitblocks[i], true) preinitblocks[i] = nil end end end local curmsg = '' local function AIO_Timeout() error(string.format('AIO Timeout. Your code ran over %s instructions with message:%s', ''..AIO_TIMEOUT_INSTRUCTIONCOUNT..'', (curmsg or 'nil'))) end local function _AIO_ParseBlocks(msg, player) AIO_debug('Received messagelength:', #msg) if AIO_ENABLE_MSGPRINT then print('received:', msg) end local data = AIO_pcall(Smallfolk.loads, msg, #msg) if not data or type(data) ~= 'table' then AIO_debug('Received invalid message - data not a table') return end for i = 1, #data do AIO_pcall(AIO_HandleBlock, player, data[i]) end end local function AIO_ParseBlocks(msg, player) AIO_pcall(_AIO_ParseBlocks, msg, player) end local function _AIO_HandleIncomingMsg(msg, player) local msgid = ssub(msg, 1,2) if msgid == AIO_ShortMsg then AIO_ParseBlocks(ssub(msg, 3), player) return end if #msg < 3*2 then return end local messageId = AIO_stringto16(msgid) local parts = AIO_stringto16(ssub(msg, 3,4)) local partId = AIO_stringto16(ssub(msg, 5,6)) if partId <= 0 or partId > parts then error('received long message with invalid amount of parts. id, parts: '..partId..' '..parts) return end msg = ssub(msg, 7) local guid = 1 if not plrdata[guid] then plrdata[guid] = { stored = 0, ramque = NewQueue(), MSG_GUID = MSG_MIN, } end local pdata = plrdata[guid] pdata[messageId] = pdata[messageId] or {} local data = pdata[messageId] if not data.parts or data.parts.n ~= parts then if data.parts then for i = 0, data.parts.n do data.parts[i] = nil end end data.guid = guid data.parts = {n=parts} data.id = messageId data.stamp = AIO_GetTime() data.remquepos = removeque:pushright(data) data.ramquepos = pdata.ramque:pushright(data) end data.parts[partId] = msg pdata.stored = pdata.stored + #msg if #data.parts == data.parts.n then local cat = tconcat(data.parts) RemoveData(guid, messageId) AIO_ParseBlocks(cat, player) end end local function AIO_HandleIncomingMsg(msg, player) AIO_pcall(_AIO_HandleIncomingMsg, msg, player) end  function AIO.RegisterEvent(name, func) assert(name ~= nil, 'name of the registered event expected not nil') assert(type(func) == 'function', 'callback function must be a function') assert(not AIO_BLOCKHANDLES[name], 'an event is already registered for the name: '..name) AIO_BLOCKHANDLES[name] = func end  function AIO.AddHandlers(name, handlertable) assert(name ~= nil, '#1 expected not nil') assert(type(handlertable) == 'table', '#2 a table expected')  for k,v in pairs(handlertable) do assert(type(v) == 'function', '#2 a table of functions expected, found a '..type(v)..' value') end  local function handler(player, key, ...) if key and handlertable[key] then handlertable[key](player, ...) end end AIO.RegisterEvent(name, handler) return handlertable end  function AIO.AddAddon(path, name) end  function AIO.Handle(name, handlername, ...) assert(name ~= nil, '#1 expected not nil') return AIO.Msg():Add(name, handlername, ...):Send() end  function AIO.AddSavedVar(key) assert(key ~= nil, '#1 table key expected') AIO_SAVEDVARS[key] = true end  function AIO.AddSavedVarChar(key) assert(key ~= nil, '#1 table key expected') AIO_SAVEDVARSCHAR[key] = true end  AIO_FRAMEPOSITIONS = AIO_FRAMEPOSITIONS or {} AIO.AddSavedVar('AIO_FRAMEPOSITIONS') AIO_FRAMEPOSITIONSCHAR = AIO_FRAMEPOSITIONSCHAR or {} AIO.AddSavedVarChar('AIO_FRAMEPOSITIONSCHAR') function AIO.SavePosition(frame, char) assert(frame:GetName(), 'Called AIO.SavePosition on a nameless frame') local store = char and AIO_FRAMEPOSITIONSCHAR or AIO_FRAMEPOSITIONS if not store[frame:GetName()] then store[frame:GetName()] = {} end LibWindow.RegisterConfig(frame, store[frame:GetName()]) LibWindow.RestorePosition(frame) LibWindow.SavePosition(frame) table.insert(AIO_SAVEDFRAMES, frame) end local function ONADDONMSG(self, event, prefix, msg, Type, sender) if prefix == AIO_ServerPrefix then if event == 'CHAT_MSG_ADDON' and sender == UnitName('player') then AIO_HandleIncomingMsg(msg, sender) end end end local MsgReceiver = CreateFrame('Frame') MsgReceiver:RegisterEvent('CHAT_MSG_ADDON') MsgReceiver:SetScript('OnEvent', ONADDONMSG) local function RunAddon(name) local code = AIO_sv_Addons[name] and AIO_sv_Addons[name].code assert(code, 'Addon doesnt exist') local compression, compressedcode = ssub(code, 1, 1), ssub(code, 2) if compression == AIO_Compressed then compressedcode = assert(lualzw.decompress(compressedcode)) end assert(loadstring(compressedcode, name))() end function AIO_HANDLERS.Init(player, version, N, addons, cached) if(AIO_VERSION ~= version) then AIO_INITED = true AIO_HandleBlock = function() end print('You have AIO version '..AIO_VERSION..' and the server uses '..(version or 'nil')..'. Get the same version') return end assert(type(N) == 'number') assert(type(addons) == 'table') assert(type(cached) == 'table') local validAddons = {} for i = 1, N do local name if addons[i] then name = addons[i].name AIO_sv_Addons[name] = addons[i] validAddons[name] = true elseif cached[i] then name = cached[i] validAddons[name] = true else error('Unexpected behavior, try /aio reset') end AIO_pcall(RunAddon, name) end local invalidAddons = {} for name, data in pairs(AIO_sv_Addons) do if not validAddons[name] then invalidAddons[#invalidAddons+1] = name end end for i = 1, #invalidAddons do local inv = invalidAddons[i] AIO_sv_Addons[inv] = nil end AIO_INITED = true print('Initialized AIO version '..AIO_VERSION..'. Type `/aio help` for commands') end function AIO_HANDLERS.ForceReload(player) local frame = CreateFrame('BUTTON') frame:SetToplevel(true) frame:SetFrameStrata('TOOLTIP') frame:SetFrameLevel(100) frame:SetAllPoints(WorldFrame) frame:SetScript('OnClick', ReloadUI) print('AIO: Force reloading UI') message('AIO: Force reloading UI') end function AIO_HANDLERS.ForceReset(player) AIO_RESET() AIO_HANDLERS.ForceReload(player) end local frame = CreateFrame('FRAME') frame:RegisterEvent('PLAYER_LOGOUT') function frame:OnEvent(event, addon) if event == 'ADDON_LOADED' and addon == 'AIO_Client' then local _,_,_, tocversion = GetBuildInfo() if tocversion and tocversion >= 40100 and RegisterAddonMessagePrefix then RegisterAddonMessagePrefix('C'..AIO_Prefix) end if type(AIO_sv) ~= 'table' then AIO_sv = {} end if type(AIO_sv_char) ~= 'table' then AIO_sv_char = {} end if type(AIO_sv_Addons) ~= 'table' then AIO_sv_Addons = {} end for k,v in pairs(AIO_sv) do if _G[k] then AIO_debug('Overwriting global var _G['..k..'] with a saved var') end _G[k] = v end for k,v in pairs(AIO_sv_char) do if _G[k] then AIO_debug('Overwriting global var _G['..k..'] with a saved character var') end _G[k] = v end local rem = {} local addons = {} for name, data in pairs(AIO_sv_Addons) do if type(name) ~= 'string' or type(data) ~= 'table' or type(data.crc) ~= 'number' or type(data.code) ~= 'string' then table.insert(rem, name) else addons[name] = data.crc end end for _,name in ipairs(rem) do AIO_sv_Addons[name] = nil end local initmsg = AIO.Msg():Add('AIO', 'Init', AIO_VERSION, addons) local reset = 1 local timer = reset local function ONUPDATE(self, diff) if AIO_INITED then self:SetScript('OnUpdate', nil) initmsg = nil reset = nil timer = nil return end if timer < diff then initmsg:Send() timer = reset reset = reset * 1.5 else timer = timer - diff end end frame:SetScript('OnUpdate', ONUPDATE) elseif event == 'PLAYER_LOGOUT' then AIO_sv = {} for key,_ in pairs(AIO_SAVEDVARS or {}) do AIO_sv[key] = _G[key] end AIO_sv_char = {} for key,_ in pairs(AIO_SAVEDVARSCHAR or {}) do AIO_sv_char[key] = _G[key] end for k,v in ipairs(AIO_SAVEDFRAMES or {}) do LibWindow.SavePosition(v) end end end frame:SetScript('OnEvent', frame.OnEvent) AIO.AddHandlers('AIO', AIO_HANDLERS) local cmds = {} local helps = {} local function pprint(player, ...) if player then player:SendBroadcastMessage(tconcat({...}, ' ')) else print(...) end end SLASH_AIO1 = '/aio' function SlashCmdList.AIO(msg) local msg = msg:lower() if msg and msg ~= '' then for k,v in pairs(cmds) do if k:find(msg, 1, true) == 1 then v() return end end end print('Unknown command /aio '..tostring(msg)) cmds.help() end helps.help = 'prints this list' function cmds.help(player) pprint(player, 'Available commands:') for k,v in pairs(cmds) do pprint(player, '/aio '..k..' - '..(helps[k] or 'no info')) end end helps.reset = 'resets local AIO cache - clears saved addons and their saved variables and reloads the UI' function cmds.reset() AIO_RESET() ReloadUI() end helps.trace = 'toggles using debug.traceback or _ERRORMESSAGE' function cmds.trace(player) AIO_ENABLE_TRACEBACK = not AIO_ENABLE_TRACEBACK pprint(player, 'using trace is now', AIO_ENABLE_TRACEBACK and 'on' or 'off') end helps.debug = 'toggles showing of debug messages' function cmds.debug(player) AIO_ENABLE_DEBUG_MSGS = not AIO_ENABLE_DEBUG_MSGS pprint(player, 'showing debug messages is now', AIO_ENABLE_DEBUG_MSGS and 'on' or 'off') end helps.pcall = 'toggles using pcall' function cmds.pcall(player) AIO_ENABLE_PCALL = not AIO_ENABLE_PCALL pprint(player, 'using pcall is now', AIO_ENABLE_PCALL and 'on' or 'off') end helps.printio = 'toggles printing all sent and received messages' function cmds.printio(player) AIO_ENABLE_MSGPRINT = not AIO_ENABLE_MSGPRINT pprint(player, 'printing IO is now', AIO_ENABLE_MSGPRINT and 'on' or 'off') end frame:OnEvent('ADDON_LOADED', 'AIO_Client') return AIO"
